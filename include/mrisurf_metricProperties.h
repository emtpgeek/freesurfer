#pragma once
/*
 * @file utilities common to mrisurf*.c but not used outside them
 *
 */
/*
 * surfaces Author: Bruce Fischl, extracted from mrisurf.c by Bevin Brett
 *
 * $ Â© copyright-2014,2018 The General Hospital Corporation (Boston, MA) "MGH"
 *
 * Terms and conditions for use, reproduction, distribution and contribution
 * are found in the 'FreeSurfer Software License Agreement' contained
 * in the file 'LICENSE' found in the FreeSurfer distribution, and here:
 *
 * https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense
 *
 * Reporting: freesurfer@nmr.mgh.harvard.edu
 *
 */
// Configurable support for checking that some of the parallel loops get the same
// results regardless of thread count
//
// Two common causes of this being false are
//          floating point reductions
//          random numbers being generated by parallel code 
//

#include "mrisurf_topology.h"

int  mrisCheckSurface( MRIS       * mris);
bool mrisCheckDist    (MRIS const * mris);
bool mrisCheckDistOrig(MRIS const * mris);

void MRISmakeDist(MRIS *mris, int vno);

typedef struct PerThreadMRIDistance {
  MRI const * mri_distance;
  int heightTimesDepth,depth;
  float* elts;
} PerThreadMRIDistance;
PerThreadMRIDistance* makePerThreadMRIDistance(MRI const * const mri_distance);
void freePerThreadMRIDistance(PerThreadMRIDistance** ptdp);
float* perThreadMRIDistanceElt(PerThreadMRIDistance* ptd, int i, int j, int k);
void updateDistanceElt(volatile float* f, float distance, bool lockNeeded);
void updateDistanceEltFromSignArgAndSquareLockNeeded(volatile float* f, float distanceSignArg, float distanceSquared);
void updateDistanceEltFromSignArgAndSquareNoLockNeeded(
    volatile float* f, 
    float distanceSignArg, 
    float distanceSquared,
    float sqrtfDistanceSquared);

int mrisFindAllOverlappingFaces(MRIS *mris, MHT *mht, int fno, int *flist);
    
int mrisCalculateFaceCentroid(MRIS *mris, int fno, float *px, float *py, float *pz);

#define NOT_PROCESSED_YET 1000
#define NPY               NOT_PROCESSED_YET

/* volume floats */
#define xVOL(mri, x) (mri->xsize * (x - mri->xstart))
#define yVOL(mri, y) (mri->ysize * (y - mri->ystart))
#define zVOL(mri, z) (mri->zsize * (z - mri->zstart))
/* volume integers */
#define iVOL(mri, x) ((int)(xVOL(mri, x) + 0.5))
#define jVOL(mri, y) ((int)(yVOL(mri, y) + 0.5))
#define kVOL(mri, z) ((int)(zVOL(mri, z) + 0.5))
/* surface floats */
#define xSURF(mri, x) (mri->xstart + (float)x / mri->xsize)
#define ySURF(mri, y) (mri->ystart + (float)y / mri->ysize)
#define zSURF(mri, z) (mri->zstart + (float)z / mri->zsize)


int mrisComputeTangentPlanes(MRIS *mris);

extern double l_mri;
extern double l_unmri;
extern double l_curv;
extern double l_qcurv;

extern double l_vol;
extern double l_surf;
extern double l_wm;

#if SPHERE_INTERSECTION
int containsAnotherVertexOnSphere(MRIS *mris, int vno0, int vno1, int vno2, int mode);
#else
int containsAnotherVertex(MRIS *mris, int vno0, int vno1, int vno2, double e0[3], double e1[3], double origin[3]);
#endif

void computeVertexPseudoNormal(MRIS const *mris, int vno, float norm[3], int verbose);

void computeDefectFaceNormal_calculate(
    MRIS const * const mris, int const fno, float* p_nx, float* p_ny, float* p_nz, float* p_orig_area);

void  setFaceNorm    (MRIS const * const mris, int fno, float nx, float ny, float nz);
void  setFaceOrigArea(MRIS const * const mris, int fno, float orig_area);
float getFaceOrigArea(MRIS const * const mris, int fno);

int mrisChooseFace(MRIS *mris, MHT *mht, VERTEX *v);

void computeDefectFaceNormal(MRIS const * const mris, int const fno);

void mrisurf_deferSetFaceNorms  (MRIS* mris);
void mrisurf_recomputeFaceNorms (MRIS* mris);
void mrisurf_undeferSetFaceNorms(MRIS* mris);

int mrisMarkIntersections(MRIS *mris);

#define OUTSIDE_VERTEX 0
#define INSIDE_VERTEX 1               /* not yet used */
#define EDGE_VERTEX 2                 /* part of an edge */
#define TRIANGLE_VERTEX 3             /* part of a triangle */
#define DISCARDED_VERTEX 4            /* excluded from the current tessellation */
#define BORDER_VERTEX TRIANGLE_VERTEX /* part of a triangle! */
#define USED_VERTEX 5                 /* used in the final tessellation */

void mrisDumpFace(MRIS *mris, int fno, FILE *fp);


int    MRIScomputeAllDistances           (MRIS *mris);
void   MRIScomputeAvgInterVertexDist     (MRIS *Surf, double *StdDev);
void   mrisSetAvgInterVertexDist         (MRIS *Surf, double to);
int    mrisTrackTotalDistance            (MRIS *mris);
int    mrisTrackTotalDistanceNew         (MRIS *mris);

float  mrisComputeArea                   (MRIS *mris, int fac, int n);
float  MRIScomputeOrigArea               (MRIS* mris);
void   MRISsetOrigArea                   (MRIS* mris);


int mrisComputeBoundaryNormals(MRIS *mris);

int mrisComputeCurvatureMinMax(MRIS *mris);

int mrisComputeNormalDotDistribution(MRIS *mris, HISTOGRAM *h_dot);

int mrisComputePrincipalCurvatureDistributions(MRIS *mris,
                                                      HISTOGRAM *h_k1,
                                                      HISTOGRAM *h_k2,
                                                      MRI *mri_k1_k2);

float mrisDefectFaceMRILogLikelihood(
    MRIS *mris, MRI *mri, TP *tp, HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white);

float mrisDefectVertexMRILogLikelihood(
    MRIS *mris, MRI *mri, TP *tp, HISTOGRAM *h_white, HISTOGRAM *h_gray, HISTOGRAM *h_grad, MRI *mri_gray_white);

#if MATRIX_ALLOCATION
extern MATRIX *VoxelFromSRASmatrix;
int mriSurfaceRASToVoxel(double xr, double yr, double zr, double *xv, double *yv, double *zv);
#endif

float  mrisSampleAshburnerTriangleEnergy    (MRIS * const mris, int const vno, INTEGRATION_PARMS * const parms, float cx, float cy, float cz);
double mrisComputeThicknessSmoothnessEnergy (MRIS *mris, double l_tsmooth, INTEGRATION_PARMS *parms);
float  mrisSampleMinimizationEnergy         (MRIS *mris, VERTEX *v,        INTEGRATION_PARMS *parms, float cx, float cy, float cz);
float  mrisSampleParallelEnergyAtVertex     (MRIS *mris, int const vno, INTEGRATION_PARMS *parms);
float  mrisSampleParallelEnergy             (MRIS *mris, int const vno, INTEGRATION_PARMS *parms, float cx, float cy, float cz);
float  mrisSampleNormalEnergy               (MRIS *mris, VERTEX *v,     INTEGRATION_PARMS *parms, float cx, float cy, float cz);
float  mrisSampleSpringEnergy               (MRIS *mris, int const vno, float cx, float cy, float cz, INTEGRATION_PARMS *parms);

int mrisComputeOrigNormal (MRIS *mris, int vno, float norm[]);
int mrisComputeWhiteNormal(MRIS *mris, int vno, float norm[]);
int mrisComputePialNormal (MRIS *mris, int vno, float norm[]);

int mrisFindUnambiguousFace(MRIS *mris, MHT *mht, VERTEX *v, int *pnfound);


typedef struct ComputeDefectContext {
    RealmTree* realmTree;
    MRIS*      mris_deferred_norms;
} ComputeDefectContext;

static void constructComputeDefectContext(ComputeDefectContext* computeDefectContext) {
    bzero(computeDefectContext, sizeof(*computeDefectContext));
}

void computeDefectFaceNormal_calculate(
    MRIS const * const mris, int const fno, float* p_nx, float* p_ny, float* p_nz, float* p_orig_area);

#define VERTEX_EDGE(vec, v0, v1)           VECTOR_LOAD(vec, v1->x     - v0->x,     v1->y     - v0->y,     v1->z     - v0->z)
#define VERTEX_ORIG_EDGE(vec, v0, v1)      VECTOR_LOAD(vec, v1->origx - v0->origx, v1->origy - v0->origy, v1->origz - v0->origz)
#define VERTEX_CANONICAL_EDGE(vec, v0, v1) VECTOR_LOAD(vec, v1->cx    - v0->cx,    v1->cy    - v0->cy,    v1->cz    - v0->cz)


// Just the information needed to compute the metric properties
//
typedef struct MRIS_MP {

#define SEP
#define ELTX(C,T,N) ELT(C,T,N)

    MRIS* underlyingMRIS;  // allows access in a few rare cases where there is a real benefit 
    
  // MRIS
  //
  // In
  //
#define ELT(C,T,N) T C N;

  #define MRIS_MP__LIST_MRIS_IN \
    ELT(const,  int,    nvertices   ) SEP \
    ELT(const,  int,    nfaces      ) SEP \
    ELT(const,  int,    nsize       ) SEP \
    ELT(const,  int,    patch       ) SEP \
    ELT(const,  int,    noscale     ) SEP \
    ELT(const,  float,  orig_area   ) SEP \
    ELT(const,  VERTEX_TOPOLOGY const *, vertices_topology) \
    ELTX(const, FACE_TOPOLOGY   const *, faces_topology)

    MRIS_MP__LIST_MRIS_IN
    
  // In out
  #define MRIS_MP__LIST_MRIS_IN_OUT \
    ELT(,       int,    status      ) SEP \
    ELT(,       double, radius      ) SEP \
    ELT(,       int,    dist_nsize  ) \

    MRIS_MP__LIST_MRIS_IN_OUT
  
  // Out
  #define MRIS_MP__LIST_MRIS_OUT \
    ELT(,       float,   xlo        ) SEP   \
    ELT(,       float,   xhi        ) SEP   \
    ELT(,       float,   ylo        ) SEP   \
    ELT(,       float,   yhi        ) SEP   \
    ELT(,       float,   zlo        ) SEP   \
    ELT(,       float,   zhi        ) SEP   \
    ELT(,       float,   xctr       ) SEP   \
    ELT(,       float,   yctr       ) SEP   \
    ELT(,       float,   zctr       ) SEP   \
    ELT(,       float,   total_area ) SEP   \
    ELT(,       double,  avg_vertex_area ) SEP   \
    ELTX(,      double,  avg_vertex_dist ) SEP   \
    ELT(,       double,  std_vertex_dist ) SEP   \
    ELT(,       float,   neg_orig_area   ) SEP   \
    ELT(,       float,   neg_area        ) 

    MRIS_MP__LIST_MRIS_OUT

#undef ELT

  // Vertices
  //
#define ELT(C,T,N) C T * v_##N;

  // In
  #define MRIS_MP__LIST_V_IN                \
    ELT(const,  char,   ripflag     ) SEP   \
    ELTX(const, int,    VSize       )
    
    MRIS_MP__LIST_V_IN

  // In out
  #define MRIS_MP__LIST_V_IN_OUT            \
    ELTX(,      int,    dist_capacity) SEP  \
    ELT(,       char,   border      ) SEP   \
    ELT(,       float,  x           ) SEP   \
    ELT(,       float,  y           ) SEP   \
    ELT(,       float,  z           ) SEP   \
    ELT(,       float,  origarea    ) 
  
    MRIS_MP__LIST_V_IN_OUT
    
  // Out
  #define MRIS_MP__LIST_V_OUT               \
    ELT(,       float,  area        ) SEP   \
    ELT(,       float,  nx          ) SEP   \
    ELT(,       float,  ny          ) SEP   \
    ELT(,       float,  nz          ) SEP   \
    ELTX(,      char,   neg         ) SEP   \
    ELTX(,      float*, dist        )

    MRIS_MP__LIST_V_OUT

#undef ELT

  // Faces
  //
#define ELT(C,T,N) C T * f_##N;
  #define MRIS_MP__LIST_F_IN                                    \
    ELT(const,  char,                   ripflag         ) SEP   \
    ELTX(const, float,                  norm_orig_area  )
    
    MRIS_MP__LIST_F_IN

  #define MRIS_MP__LIST_F_OUT                                   \
    ELT(,       float,                  area            ) SEP   \
    ELTX(,      char,                   normSet         ) SEP   \
    ELTX(,      FloatXYZ,               norm            ) SEP   \
    ELTX(,      angles_per_triangle_t,  angle)

    MRIS_MP__LIST_F_OUT
    
#undef ELT

#undef ELTX
#undef SEP

} MRIS_MP;

void MRISMP_ctr(MRIS_MP* mp);
void MRISMP_dtr(MRIS_MP* mp);
void MRISMP_copy(MRIS_MP* dst, MRIS_MP* src, 
    bool only_inputs,           // if true, copy the in and in_out fields only
    bool ignore_xyz);           // if true, don't copy the v_x[*] v_y[*] v_z[*]     NYI
    
void MRISMP_load(MRIS_MP* mp, MRIS* mris,
  float * dx_or_NULL, float * dy_or_NULL, float * dz_or_NULL);      // loaded if not NULL, the dx,dy,dz for ripped set to zero

void MRISMP_translate_along_vertex_dxdydz(MRIS_MP* mris_src, MRIS_MP* mris_dst, 
  double dt,
  float const* dx, float const* dy, float const* dz);               // the dx,dy,dz for ripped should be zero

void MRISMP_computeMetricProperties(MRIS_MP* mris);
void MRISMP_updateEllipsoidSurface(MRIS_MP* mris);
